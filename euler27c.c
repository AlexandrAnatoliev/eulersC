// euler27c - Квадратичные простые числа

//Эйлер опубликовал свою замечательную квадратичную формулу :

//n2 + n + 41

//Оказалось, что согласно данной формуле можно получить 40 простых чисел, последовательно подставляя значения 0≤n≤39

//Однако, при n = 40,
// 402 + 40 + 41 = 40(40 + 1) + 41
//делится на 41 без остатка, и, очевидно, при n = 41, 412 + 41 + 41
//делится на 41 без остатка.
//
//При помощи компьютеров была найдена невероятная формула 

// n2−79n + 1601

//, согласно которой можно получить 80 простых чисел для последовательных значений n
//от 0 до 79. Произведение коэффициентов −79 и 1601 равно −126479.

//Рассмотрим квадратичную формулу вида :

//n2 + an + b
//, где | a | < 1000
//    и | b | ≤1000
//
//    где | n |
//    является модулем(абсолютным значением) n
//    
//    К примеру, | 11 |= 11 и | −4 |= 4
//    Найдите произведение коэффициентов a и b квадратичного выражения, 
// согласно которому можно получить максимальное количество простых чисел для последовательных значений n, начиная со значения n = 0

#include <stdio.h>
#include <stdbool.h>                                                //для красоты кода использую bool
#include <math.h>                                                   //для использовании функции sqrt()

#define LEN_ARR 15000                                               //принял длину масиива опытным путем

bool is_simple(int num_arg)
//функция принимает число и возвращает true - если число простое
{
    int i_arg = sqrt(num_arg) + 1;                                  //выносим вычисление квадратного корня из цикла for

    for (int i = 2; i < i_arg; i++)                                 //чтобы он не вычислялся каждую итерацию цикла
    {
        if (num_arg % i == 0)
            return false;
    }
    return true;
}
int main(void)
{
    char arr[LEN_ARR] = {0};                                        //массив для записи простых чисел
    int n, answ_a, answ_b, a, b, cnt, answ = 1, cnt_max = 0;

    //вычисляю простые числа до 15000 один раз и заношу их массив по индексу
    for (int i = 1; i < LEN_ARR; i++)                               //если arr[indx] = 1 => indx - простое число 
        arr[i] = is_simple(i);

    //в цикле перебираю все возможные коэффициенты
    for (a = -1000; a < 1000; a++)
    {
        for (b = -1000; b < 1000; b++)
        {
            cnt = 0;
            n = 0;
            for(n = 0; n < 100; n++)                                //предположил, что простых чисел будет не более ста
            {
                answ = (n * n) + (a * n) + b;                       //проверяем формулу
                if (answ < 0 || arr[answ] == 0)                     //простое число не может быть отрицательным
                    break;                                          //прервем проверку формулы если встретилось число не являющееся простым
                            
                cnt++;
            }

            if (cnt > cnt_max)                                      //обновляем значения коэффициентов
            {
                cnt_max = cnt;
                answ_a = a;
                answ_b = b;
            }            
        }
    }
         
    printf("cnt = %d\na*b = %d", cnt_max - 1, answ_a*answ_b);       //cnt = 70 a*b = -59231
    return 0;
}