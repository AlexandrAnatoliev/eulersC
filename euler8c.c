//euler8c - Наибольшее произведение в последовательности
//Наибольшее произведение четырех последовательных цифр в нижеприведенном 1000-значном числе равно 9 × 9 × 8 × 9 = 5832.
//Найдите наибольшее произведение тринадцати последовательных цифр в данном числе   

// 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843
// 8586156078911294949545950173795833195285320880551112540698747158523863050715693290963295227443043557
// 6689664895044524452316173185640309871112172238311362229893423380308135336276614282806444486645238749
// 3035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776
// 6572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397
// 5369781797784617406495514929086256932197846862248283972241375657056057490261407972968652414535100474
// 8216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586
// 1786645835912456652947654568284891288314260769004224219022671055626321111109370544217506941658960408
// 0719840385096245544436298123098787992724428490918884580156166097919133875499200524063689912560717606
// 0588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

//наивный вариант
// #include <stdio.h>

// int main(void)
// {   
//     int answ = 0;
//     int prod = 1;
//     int num_array[1000] = {7,3,1,6,7,1,7,6,5,3,1,3,3,0,6,2,4,9,1,9,2,2,5,1,1,9,6,7,4,4,2,6,5,7,4,7,4,2,3,5,5,3,4,9,1,9,4,9,3,4,9,6,9,8,3,5,2,0,3,1,2,7,7,4,5,0,6,3,2,6,2,3,9,5,7,8,3,1,8,0,1,6,9,8,4,8,0,1,8,6,9,4,7,8,8,5,1,8,4,3,8,5,8,6,1,5,6,0,7,8,9,1,1,2,9,4,9,4,9,5,4,5,9,5,0,1,7,3,7,9,5,8,3,3,1,9,5,2,8,5,3,2,0,8,8,0,5,5,1,1,1,2,5,4,0,6,9,8,7,4,7,1,5,8,5,2,3,8,6,3,0,5,0,7,1,5,6,9,3,2,9,0,9,6,3,2,9,5,2,2,7,4,4,3,0,4,3,5,5,7,6,6,8,9,6,6,4,8,9,5,0,4,4,5,2,4,4,5,2,3,1,6,1,7,3,1,8,5,6,4,0,3,0,9,8,7,1,1,1,2,1,7,2,2,3,8,3,1,1,3,6,2,2,2,9,8,9,3,4,2,3,3,8,0,3,0,8,1,3,5,3,3,6,2,7,6,6,1,4,2,8,2,8,0,6,4,4,4,4,8,6,6,4,5,2,3,8,7,4,9,3,0,3,5,8,9,0,7,2,9,6,2,9,0,4,9,1,5,6,0,4,4,0,7,7,2,3,9,0,7,1,3,8,1,0,5,1,5,8,5,9,3,0,7,9,6,0,8,6,6,7,0,1,7,2,4,2,7,1,2,1,8,8,3,9,9,8,7,9,7,9,0,8,7,9,2,2,7,4,9,2,1,9,0,1,6,9,9,7,2,0,8,8,8,0,9,3,7,7,6,6,5,7,2,7,3,3,3,0,0,1,0,5,3,3,6,7,8,8,1,2,2,0,2,3,5,4,2,1,8,0,9,7,5,1,2,5,4,5,4,0,5,9,4,7,5,2,2,4,3,5,2,5,8,4,9,0,7,7,1,1,6,7,0,5,5,6,0,1,3,6,0,4,8,3,9,5,8,6,4,4,6,7,0,6,3,2,4,4,1,5,7,2,2,1,5,5,3,9,7,5,3,6,9,7,8,1,7,9,7,7,8,4,6,1,7,4,0,6,4,9,5,5,1,4,9,2,9,0,8,6,2,5,6,9,3,2,1,9,7,8,4,6,8,6,2,2,4,8,2,8,3,9,7,2,2,4,1,3,7,5,6,5,7,0,5,6,0,5,7,4,9,0,2,6,1,4,0,7,9,7,2,9,6,8,6,5,2,4,1,4,5,3,5,1,0,0,4,7,4,8,2,1,6,6,3,7,0,4,8,4,4,0,3,1,9,9,8,9,0,0,0,8,8,9,5,2,4,3,4,5,0,6,5,8,5,4,1,2,2,7,5,8,8,6,6,6,8,8,1,1,6,4,2,7,1,7,1,4,7,9,9,2,4,4,4,2,9,2,8,2,3,0,8,6,3,4,6,5,6,7,4,8,1,3,9,1,9,1,2,3,1,6,2,8,2,4,5,8,6,1,7,8,6,6,4,5,8,3,5,9,1,2,4,5,6,6,5,2,9,4,7,6,5,4,5,6,8,2,8,4,8,9,1,2,8,8,3,1,4,2,6,0,7,6,9,0,0,4,2,2,4,2,1,9,0,2,2,6,7,1,0,5,5,6,2,6,3,2,1,1,1,1,1,0,9,3,7,0,5,4,4,2,1,7,5,0,6,9,4,1,6,5,8,9,6,0,4,0,8,0,7,1,9,8,4,0,3,8,5,0,9,6,2,4,5,5,4,4,4,3,6,2,9,8,1,2,3,0,9,8,7,8,7,9,9,2,7,2,4,4,2,8,4,9,0,9,1,8,8,8,4,5,8,0,1,5,6,1,6,6,0,9,7,9,1,9,1,3,3,8,7,5,4,9,9,2,0,0,5,2,4,0,6,3,6,8,9,9,1,2,5,6,0,7,1,7,6,0,6,0,5,8,8,6,1,1,6,4,6,7,1,0,9,4,0,5,0,7,7,5,4,1,0,0,2,2,5,6,9,8,3,1,5,5,2,0,0,0,5,5,9,3,5,7,2,9,7,2,5,7,1,6,3,6,2,6,9,5,6,1,8,8,2,6,7,0,4,2,8,2,5,2,4,8,3,6,0,0,8,2,3,2,5,7,5,3,0,4,2,0,7,5,2,9,6,3,4,5,0};
//     for (int i =0; i  < 997; i++)
//     {
//         prod = num_array[i] * num_array[i + 1] * num_array[i + 2] * num_array[i + 3] * num_array[i + 4] * num_array[i + 5] * num_array[i + 6] * num_array[i + 7] * num_array[i + 8] * num_array[i + 9] * num_array[i + 10] * num_array[i + 11] * num_array[i + 12];
//         if (prod > answ) answ = prod;
//     }    
//     printf("%d",answ);              //2091059712 - неверно
//     return 0;

// }

// euler8c - Наибольшее произведение в последовательности
// Наибольшее произведение четырех последовательных цифр в нижеприведенном 1000-значном числе равно 9 × 9 × 8 × 9 = 5832.
// Найдите наибольшее произведение тринадцати последовательных цифр в данном числе   

// Продвинутый алгоритм
// #include <stdio.h>
// #include <string.h>
// #include <stdlib.h>

// int main (void)
// {
//     //объявил 1000-значное число из задания в виде строки
//     char num_str[] =    "73167176531330624919225119674426574742355349194934"
//                         "96983520312774506326239578318016984801869478851843"
//                         "85861560789112949495459501737958331952853208805511"
//                         "12540698747158523863050715693290963295227443043557"
//                         "66896648950445244523161731856403098711121722383113"
//                         "62229893423380308135336276614282806444486645238749"
//                         "30358907296290491560440772390713810515859307960866"
//                         "70172427121883998797908792274921901699720888093776"
//                         "65727333001053367881220235421809751254540594752243"
//                         "52584907711670556013604839586446706324415722155397"
//                         "53697817977846174064955149290862569321978468622482"
//                         "83972241375657056057490261407972968652414535100474"
//                         "82166370484403199890008895243450658541227588666881"
//                         "16427171479924442928230863465674813919123162824586"
//                         "17866458359124566529476545682848912883142607690042"
//                         "24219022671055626321111109370544217506941658960408"
//                         "07198403850962455444362981230987879927244284909188"
//                         "84580156166097919133875499200524063689912560717606"
//                         "05886116467109405077541002256983155200055935729725"
//                         "71636269561882670428252483600823257530420752963450";
//     //printf("%d",strlen(num_str));
    
//     char num_array[1000];
//     long long answ = 0;
//     long long prod = 1;
//     //разбиваем строку на массив цифр
//     for(int i = 0; i < 1000; i++)
//     {
//         char symb[] = {num_str[i],'\0'};
//         num_array[i] = atoi(symb);
//     }
//     //перемножаем последовательно 13 цифр      
//     for (int i = 0; i  < 987; i++)
//     {
//         prod = 1;
//         for( int j = 0; j < 13; j++)
//              prod *= num_array[i + j];        
//         // prod *= num_array[i] * num_array[i + 1] * num_array[i + 2] * num_array[i + 3] * num_array[i + 4] * num_array[i + 5] * num_array[i + 6] * num_array[i + 7] * num_array[i + 8] * num_array[i + 9] * num_array[i + 10] * num_array[i + 11] * num_array[i + 12];
//         if (prod > answ) answ = prod;
//     }    
//     printf("%lld",answ);              
//     return 0;
// }

// продвинутый вариант со структурой "змея"
#include <stdio.h>
#include <stdbool.h>

#define LEN_ARR 1000                                // длина массива с числами
#define LEN_SERIES 13                               // длина искомой серии чисел

typedef struct tip                                  // создаем структуру для хранения "оконечностей змеи"
{
    int value;                                      // текущее значение 
    int indx;                                       // текущий индекс положения в массиве
} TIP;                                              // для красоты меняем название типа данных struct tip -> TIP

typedef struct snake                                // создаем структуру для хранения "змеи" - серии чисел
{
    long long product;                              // текущее значение произведения серии чисел - "тело змеи" 
    TIP head;                                       // значение и индекс "головы змеи"
    TIP tail;                                       // значение и индекс "хвоста змеи"
    int len_snake;                                  // длина змеи
} SNAKE;                                            // для красоты меняем название типа данных struct snake -> SNAKE

bool snake_growth(SNAKE *snake, char num_arr[])
// "змея" растет - увеличивает длину, пока не достигнет длины 13 чисел или не встретит ноль
// параметры:	*snake      - указатель структуру - "змея"
//              num_arr[]   - указатель на массив с числами
// return:      true        - змея успешно выросла до длины 13 чисел
//              false       - змея встретила ноль
{
    while(snake->len_snake < LEN_SERIES)
    {
        snake->head.indx++;                         // перемещаем "голову" на шаг вперед
        snake->head.value = num_arr[snake->head.indx];

        if(!snake->head.value)                      // snake.head.value == 0
            return false;                           // встретили ноль - "змея" не выросла

        snake->product *= snake->head.value;        // изменяем "тело змеи" - произведение серии чисел
        snake->len_snake++;                         // увеличисваем длину змеи
    }
    return true;                                    // "змея" успешно выросла до 13 чисел
}

bool snake_crawl(SNAKE *snake, char num_arr[])
// "змея" ползет на один шаг, если не встретит ноль
// параметры:	*snake      - указатель структуру - "змея"
//              num_arr[]   - указатель на массив с числами
// return:      true        - "змея" успешно проползла один шаг
//              false       - "змея" встретила ноль
{
    snake->head.indx++;                             // перемещаем "голову" на шаг вперед
    snake->head.value = num_arr[snake->head.indx];

    if(!snake->head.value)                          // snake.head.value == 0
        return false;                               // встретили ноль

    snake->product /= snake->tail.value;            // обрезаем "хвост"
    snake->tail.indx++;                             // перемещаем "хвост" на шаг вперед
    snake->tail.value = num_arr[snake->tail.indx];

    snake->product *= snake->head.value;            // изменяем "тело змеи" - произведение серии чисел
    
    return true;                                    // "змея" успешно проползла один шаг
}

void snake_jump(SNAKE *snake, char num_arr[])
// "змея" перепрыгивает через ноль
// параметры:	*snake      - указатель структуру - "змея"
//              num_arr[]   - указатель на массив с числами
{
    int jump = snake->len_snake;                    // длина прыжка

    while(!num_arr[snake->tail.indx + jump])        // num_arr[snake->tail.indx + jump] == 0
        jump++;                                     // изменяем длину прыжка, чтобы не попадать на ноль

    snake->tail.indx += jump;                       // перемещаем "хвост" вперед
    snake->tail.value = num_arr[snake->tail.indx];

    snake->head.indx = snake->tail.indx;            // перемещаем "голову" вперед
    snake->head.value = num_arr[snake->head.indx];

    snake->product = snake->tail.value;             // обновляем значение "тела" змеи
    snake->len_snake = 1;                           // "змея" занимает только одно число
}

int main (void)
{
    //объявил 1000-значное число из задания в виде строки
    char num_str[] =    "73167176531330624919225119674426574742355349194934"
                        "96983520312774506326239578318016984801869478851843"
                        "85861560789112949495459501737958331952853208805511"
                        "12540698747158523863050715693290963295227443043557"
                        "66896648950445244523161731856403098711121722383113"
                        "62229893423380308135336276614282806444486645238749"
                        "30358907296290491560440772390713810515859307960866"
                        "70172427121883998797908792274921901699720888093776"
                        "65727333001053367881220235421809751254540594752243"
                        "52584907711670556013604839586446706324415722155397"
                        "53697817977846174064955149290862569321978468622482"
                        "83972241375657056057490261407972968652414535100474"
                        "82166370484403199890008895243450658541227588666881"
                        "16427171479924442928230863465674813919123162824586"
                        "17866458359124566529476545682848912883142607690042"
                        "24219022671055626321111109370544217506941658960408"
                        "07198403850962455444362981230987879927244284909188"
                        "84580156166097919133875499200524063689912560717606"
                        "05886116467109405077541002256983155200055935729725"
                        "71636269561882670428252483600823257530420752963450";
    
    char num_arr[LEN_ARR];
    long long answ = 0;
    bool is_answ = false;                           // флаг наличия ответа (отсутствия нуля в серии чисел)

    for(int i = 0; i < LEN_ARR; i++)                // преобразуем строку в массив цифр   
        num_arr[i] = num_str[i] - 48;               // символ '0' имеет код 48, '1' - 49 и т.д.
    
    SNAKE Snake;                                    // создаем стркутуру "змея" - массив чисел из одного числа
    Snake.product = num_arr[0];                     // произведение равно первому числу массива
    Snake.len_snake = 1;                            // "длина змеи" - одно число
    Snake.head.indx = 0;                            // "голова" 
    Snake.head.value = num_arr[0];
    Snake.tail.indx = 0;                            // и "хвост" также находятся в первом числе массива
    Snake.tail.value = num_arr[0];

    while (Snake.head.indx < LEN_ARR)               // пока не дойдем до конца массива
    {
        if(Snake.len_snake < LEN_SERIES)            // "змея" растет
            is_answ = snake_growth(&Snake, num_arr);
        else                                        // или ползет
            is_answ = snake_crawl(&Snake, num_arr);

        if(is_answ)                                 // если есть ответ - обновляем максимум
            answ = (answ > Snake.product) ? answ : Snake.product;
        else                                        // если встретился ноль - "змея" перепрыгивает через него
            snake_jump(&Snake, num_arr);
    }

    printf("%lld",answ);                    
    return 0;
}