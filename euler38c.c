// euler38c - Пан-цифровые кратные числа

// Возьмем число 192 и умножим его по очереди на 1, 2 и 3:
//
// 192 × 1 = 192
// 192 × 2 = 384
// 192 × 3 = 576
// Объединяя все три произведения, получим девятизначное число 192384576 из цифр от 1 до 9 (пан - цифровое число). 
// Будем называть число 192384576 объединенным произведением 192 и(1, 2, 3)
//
// Таким же образом можно начать с числа 9 и по очереди умножать его на 1, 2, 3, 4 и 5, что в итоге дает пан - цифровое число 918273645, 
// являющееся объединенным произведением 9 и(1, 2, 3, 4, 5).
//
// Какое самое большое девятизначное пан - цифровое число можно образовать как объединенное произведение целого числа и(1, 2, ..., n), где n > 1 ?


#include <stdio.h>
#include <stdbool.h>
#include <math.h>										//для работы функции pow()

int put_numbers(char arr_arg[], int num_arg)
// раскладывает число на цифры, сохраняет их в массив по индексу
// параметры:	char arr_arg[]	- массив для хранения индексов-чисел
//				int num_arg		- раскладываемое число
// return:		cnt				- количество занесенных в массив чисел
//				10				- такая цифра в массиве уже есть
{
	int cnt = 0;
	while (num_arg)
	{
		if (!arr_arg[num_arg % 10] && (num_arg % 10))	//arr_arg[num_arg % 10] == 0 - если такой цифры нет и она не 0
		{
			arr_arg[num_arg % 10] = 1;					//отмечаем цифру как занятую
			num_arg /= 10;								//отрезаем младшую цифру от числа
			cnt++;
		}
		else
			return 10;
	}
	return cnt;
}

bool is_pandigital(int num_arg)
// определяет возможность получить из данного числа панцифровое
// параметры:	int num_arg	- проверяемое число
// return:		true		- объединенное произведение num_arg и 1, 2... образует панцифровое число
{
	char arr[10] = { 0 };
	int n = 1;
	int cnt = 0;

	while (cnt < 9)
	{
		cnt += put_numbers(arr, num_arg * n);
		n++;
	}

	if (cnt == 9)
		return true;

	return false;
}

int split_numb(char arr_arg[], int num_arg)
// раскладывает число на цифры и заносит в массив, начиная с младшего регистра
// параметры:	char arr_arg[]	- массив для хранения чисел
//				int num_arg		- раскладываемое число
// return:		cnt				- количество занесенных в массив чисел
{										
	int cnt = 0;
	while (num_arg / 10)
	{
		arr_arg[cnt++] = num_arg % 10;					// заносим в массив цифру 
		num_arg /= 10;									// отрезаем младший регистр
	}
	arr_arg[cnt++] = num_arg % 10;	
	return cnt;
}

int get_concatenated_product(int num_arg)
// возвращает объединеное произведение
// параметры:	int num_arg	- число
// return:		объединенное произведение num_arg и 1, 2...
{
	char arr[10] = { 0 };
	char arr_num[10] = { 0 };
	int n = 1;
	int ptr = 9;
	int num = num_arg;
	int cnt_num;
	int answ = 0;

	while (ptr > 0)
	{
		// раскладываем объединенное произведение в массив arr_num[] в виде: 123*1 -> [3,2,1,0,0,0,0,0,0,0]
		cnt_num = split_numb(arr_num, num * n++);
		// копируем цифры из массива arr_num[] в arr[]: [3,2,1,0,0,0,0,0,0,0] -> [0,0,0,0,0,0,0,3,2,1]
		for (int i = ptr, j = cnt_num - 1; j >= 0; i--, j--)
			arr[i] = arr_num[j];
		// изменяем указатель для того, чтобы дальнейшие цифры по порядку:
		// 123*2 -> [6,4,2,0,0,0,0,0,0,0] -> [0,0,0,0,6,4,2,3,2,1]
		ptr -= cnt_num;
	}

	for (int i = 1, j = 0; i < 10; i++, j++)			// преобразуем массив в число [3,2,1] -> 123
		answ += arr[i] * round(pow(10, j));				// без round() функция pow() врет! 
	return answ;
}

int main(void)
{
	int max_answ = 0;
	int answ;
	for(int i = 1; i < 10000; i++)
		if (is_pandigital(i))
		{
			answ = get_concatenated_product(i);
			max_answ = (answ > max_answ) ? answ : max_answ;
		}
	printf("%d", max_answ);								// 932718654
	return 0;	
}
