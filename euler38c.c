// euler38c - Пан-цифровые кратные числа

// Возьмем число 192 и умножим его по очереди на 1, 2 и 3:
//
// 192 × 1 = 192
// 192 × 2 = 384
// 192 × 3 = 576
// Объединяя все три произведения, получим девятизначное число 192384576 из цифр от 1 до 9 (пан - цифровое число).
// Будем называть число 192384576 объединенным произведением 192 и(1, 2, 3)
//
// Таким же образом можно начать с числа 9 и по очереди умножать его на 1, 2, 3, 4 и 5, что в итоге дает пан - цифровое число 918273645,
// являющееся объединенным произведением 9 и(1, 2, 3, 4, 5).
//// 932718654
// Какое самое большое девятизначное пан - цифровое число можно образовать как объединенное произведение целого числа и(1, 2, ..., n), где n > 1 ?

// euler38c - Пан-цифровые кратные числа

// Возьмем число 192 и умножим его по очереди на 1, 2 и 3:
//
// 192 × 1 = 192
// 192 × 2 = 384
// 192 × 3 = 576
// Объединяя все три произведения, получим девятизначное число 192384576 из цифр от 1 до 9 (пан - цифровое число).
// Будем называть число 192384576 объединенным произведением 192 и(1, 2, 3)
//
// Таким же образом можно начать с числа 9 и по очереди умножать его на 1, 2, 3, 4 и 5, что в итоге дает пан - цифровое число 918273645,
// являющееся объединенным произведением 9 и(1, 2, 3, 4, 5).
//// 932718654
// Какое самое большое девятизначное пан - цифровое число можно образовать как объединенное произведение целого числа и(1, 2, ..., n), где n > 1 ?

#include <stdio.h>
#include <stdbool.h>
#include <time.h> 												// for clock_t, clock(), CLOCKS_PER_SEC
#include <locale.h>

int put_digits(char arr[], int num);
bool is_pandigital(int num);
int get_concat_prod(int num);

int main(void)
{
	setlocale(LC_ALL, "Rus"); 									// русский язык в printf()

	double time_spent = 0.0; 									// для хранения времени выполнения кода
	clock_t begin = clock(); 									// СТАРТ таймера

	int max_answ = 0;
	int answ;

	for (int num = 90; num < 10000; num++)
	{
		if (num == 100) 										// пропускаем числа не начинающиеся с девяти
			num = 900;
		else if (num == 1000)
			num = 9000;

		if (is_pandigital(num))
		{
			answ = get_concat_prod(num);
			max_answ = (answ > max_answ) ? answ : max_answ;
		}
	}

	clock_t end = clock();								  		// СТОП таймера
	time_spent += (double)(end - begin) / CLOCKS_PER_SEC; 		// время работы в секундах

	printf("Ответ = %d время = %f\n", max_answ, time_spent);	// выводим результат и время работы программы
	return 0;
}

int put_digits(char arr[], int num)
// Функция, которая раскладывает число на цифры, сохраняет их в массив по индексу
// Параметры:	arr[]	- массив для хранения индексов-чисел
//				num		- раскладываемое число
// return:		cnt		- количество занесенных в массив чисел
//				10		- такая цифра в массиве уже есть
{
	int cnt = 0;

	while (num) 								// пока число не равно нулю
	{
		if (arr[num % 10] == 0 && (num % 10)) 	// если такой цифры нет и она не рвна нулю
		{
			arr[num % 10] = 1; 					// отмечаем цифру как занятую
			num /= 10;		   					// отрезаем младшую цифру от числа
			cnt++;
		}

		else
			return 10;
	}

	return cnt;
}

bool is_pandigital(int num)
// Функция для определения возможности получить из данного числа панцифровое
// Параметры:	num		- проверяемое число
// return:		true	- объединенное произведение num и 1, 2... образует панцифровое число
{
	char arr[10] = {0}; 						// массив для хранения цифр по их индексу
	int fact = 1;
	int digits = 0;

	while (digits < 9) 							// пока не занесено 9 цифр
	{
		digits += put_digits(arr, num * fact); 	// перемножаем проверяемое число на множитель 1, 2, 3...
		fact++;
	}

	if (digits == 9)
		return true;

	return false;
}

int get_concat_prod(int num)
// Функция для получения девятизначного объединенного произведения цифр
// Параметры:	num		- исходное число
// return:		true	- объединенное произведение num и 1, 2... образует пан-цифровое число
{
	int len = 0;
	int fact = 1;
	int shift;
	int concat_prod = 0;

	while (len < 9)				// длина числа
	{
		int mult = num * fact; 	// получаем произведение числа на множитель 1, 2, 3...
		shift = 10;

		while (mult > shift)
		{
			shift *= 10; 		// уточняем порядок числа, необходимый для смещения
			len++;		 		// учитываем дополнительно вносимые цифры для двузначных и т.п. цифр
		}

		concat_prod *= shift; 	// смещаем уже занесенные цифры влево (9 -> 900)
		concat_prod += mult;	// прибаляем новое произведение (900 + 18  918)
		len++;
		fact++;
	}

	return concat_prod;
}

// #include <stdio.h>
// #include <stdbool.h>
// #include <math.h>										//для работы функции pow()

// int put_numbers(char arr_arg[], int num_arg)
// // раскладывает число на цифры, сохраняет их в массив по индексу
// // параметры:	char arr_arg[]	- массив для хранения индексов-чисел
// //				int num_arg		- раскладываемое число
// // return:		cnt				- количество занесенных в массив чисел
// //				10				- такая цифра в массиве уже есть
// {
// 	int cnt = 0;
// 	while (num_arg)
// 	{
// 		if (!arr_arg[num_arg % 10] && (num_arg % 10))	//arr_arg[num_arg % 10] == 0 - если такой цифры нет и она не 0
// 		{
// 			arr_arg[num_arg % 10] = 1;					//отмечаем цифру как занятую
// 			num_arg /= 10;								//отрезаем младшую цифру от числа
// 			cnt++;
// 		}
// 		else
// 			return 10;
// 	}
// 	return cnt;
// }

// bool is_pandigital(int num_arg)
// // определяет возможность получить из данного числа панцифровое
// // параметры:	int num_arg	- проверяемое число
// // return:		true		- объединенное произведение num_arg и 1, 2... образует панцифровое число
// {
// 	char arr[10] = { 0 };
// 	int n = 1;
// 	int cnt = 0;

// 	while (cnt < 9)
// 	{
// 		cnt += put_numbers(arr, num_arg * n);
// 		n++;
// 	}

// 	if (cnt == 9)
// 		return true;

// 	return false;
// }

// int split_numb(char arr_arg[], int num_arg)
// // раскладывает число на цифры и заносит в массив, начиная с младшего регистра
// // параметры:	char arr_arg[]	- массив для хранения чисел
// //				int num_arg		- раскладываемое число
// // return:		cnt				- количество занесенных в массив чисел
// {
// 	int cnt = 0;
// 	while (num_arg / 10)
// 	{
// 		arr_arg[cnt++] = num_arg % 10;					// заносим в массив цифру
// 		num_arg /= 10;									// отрезаем младший регистр
// 	}
// 	arr_arg[cnt++] = num_arg % 10;
// 	return cnt;
// }

// int get_concatenated_product(int num_arg)
// // возвращает объединеное произведение
// // параметры:	int num_arg	- число
// // return:		объединенное произведение num_arg и 1, 2...
// {
// 	char arr[10] = { 0 };
// 	char arr_num[10] = { 0 };
// 	int n = 1;
// 	int ptr = 9;
// 	int num = num_arg;
// 	int cnt_num;
// 	int answ = 0;

// 	while (ptr > 0)
// 	{
// 		// раскладываем объединенное произведение в массив arr_num[] в виде: 123*1 -> [3,2,1,0,0,0,0,0,0,0]
// 		cnt_num = split_numb(arr_num, num * n++);
// 		// копируем цифры из массива arr_num[] в arr[]: [3,2,1,0,0,0,0,0,0,0] -> [0,0,0,0,0,0,0,3,2,1]
// 		for (int i = ptr, j = cnt_num - 1; j >= 0; i--, j--)
// 			arr[i] = arr_num[j];
// 		// изменяем указатель для того, чтобы дальнейшие цифры по порядку:
// 		// 123*2 -> [6,4,2,0,0,0,0,0,0,0] -> [0,0,0,0,6,4,2,3,2,1]
// 		ptr -= cnt_num;
// 	}

// 	for (int i = 1, j = 0; i < 10; i++, j++)			// преобразуем массив в число [3,2,1] -> 123
// 		answ += arr[i] * round(pow(10, j));				// без round() функция pow() врет!
// 	return answ;
// }

// int main(void)
// {
// 	int max_answ = 0;
// 	int answ;
// 	for(int i = 1; i < 10000; i++)
// 		if (is_pandigital(i))
// 		{
// 			answ = get_concatenated_product(i);
// 			max_answ = (answ > max_answ) ? answ : max_answ;
// 		}
// 	printf("%d", max_answ);
// 	return 0;
// }
